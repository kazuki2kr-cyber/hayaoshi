---
title: "Next.jsで動的OGP生成に挑み、最終的に「実装しない」という決断に至った話"
emoji: "🤔"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["nextjs", "react", "ogp", "vercel", "frontend"]
published: false
---

個人開発しているクイズアプリ「Fantasy Quizzes Kingdom」に、**「クリア結果（スコアやランク）をきれいな画像付きでSNSシェアしたい！」** という機能を追加しようとしました。

よくある機能ですが、実装を進める中で **「動的OGP生成の闇」** と **「クライアントサイド生成の複雑さ」** に直面し、最終的に **「機能そのものを削ぎ落としてシンプルにする」** というピボットを行いました。

今回は、その技術的な変遷と、なぜその結論に至ったのかを「失敗と学びの記録」として残します。

## やりたかったこと

1.  ユーザーがクイズをクリアする。
2.  結果画面で「スコア」「ランク」「プレイヤー名」が表示される。
3.  「Xでシェア」ボタンを押すと、そのスコアが記載されたリッチな画像（OGP）付きで投稿される。

## Phase 1: `@vercel/og` によるサーバーサイド生成への挑戦

最初は Next.js (App Router) の王道である `@vercel/og` を使用しました。
`api/og/route.tsx` を作成し、リクエストパラメータに応じて画像をオンデマンド生成するアプローチです。

```tsx
// 当初のコードイメージ
import { ImageResponse } from '@vercel/og';

export const runtime = 'edge'; // Edge Runtimeを使用

export async function GET(req: Request) {
  const { searchParams } = new URL(req.url);
  const score = searchParams.get('score');
  
  // 背景画像を読み込み
  const bgImage = await fetch(new URL('../../../public/bg.png', import.meta.url))
    .then(res => res.arrayBuffer());

  return new ImageResponse(
    (
      <div style={{ backgroundImage: ... }}>
        <h1>Score: {score}</h1>
      </div>
    ),
    { width: 1200, height: 630 }
  );
}
```

### 直面した壁: ローカルアセットの読み込み問題
開発環境 (`npm run dev`) では完璧に動作しました。しかし、Vercelの本番環境にデプロイすると **500 Internal Server Error** が発生。

原因は **「Edge Runtime / Serverless 環境におけるローカルファイル（`public`フォルダ内の画像やフォント）の読み込み」** です。

1.  **Edge Runtimeの制約**: ファイルシステム (`fs`) が使えない。
2.  **パスの解決**: `import.meta.url` や相対パスの解決が、ビルド後の環境（バンドルされた状態）で予期せぬ挙動をする。
3.  **HTTP Fetchの罠**: 自分自身のホストにある画像を取得しようとして、認証やネットワーク経路の問題で失敗する。

「Node.js Runtimeに戻して `fs` を使う」「`fetch` のURL解決を工夫する」など試行錯誤しましたが、デプロイのたびに不安定になる挙動に疲弊し始めました。

## Phase 2: `html2canvas` によるクライアントサイド生成への迷走

サーバーサイドが難しいなら、クライアントサイドで、「ユーザーが見ている結果画面」をそのまま画像化してしまえばいいのでは？と考えました。

1.  Reactで結果コンポーネントを表示。
2.  `html2canvas` でそのDOMをキャプチャし、Base64画像化。
3.  それをFirebase Storageなどにアップロードして、そのURLをOGPにする…？

### 直面した壁: UXの崩壊と複雑性
実装しかけたところ、**「シェアするだけなのに、処理が重すぎる」** ことに気づきました。

*   **待機時間**: 画像生成→アップロードの待ち時間が発生する。
*   **不確実性**: クライアントのブラウザ環境によって、フォントがズレたり画像が欠けたりする（CORS汚染問題など）。
*   **ストレージコスト**: 一時的なシェアのために、ゴミのような画像ファイルがストレージに無限に溜まっていくリスク。

「たかがシェア機能のために、ここまでアーキテクチャを複雑にする必要があるのか？」という疑問が湧きました。

## Phase 3: 「画像を捨て、体験を取る」という決断 (Final Solution)

ここで原点に立ち返りました。
**ユーザーは「動的に生成された画像」を見たいのか？**
**それとも、「自分のスコアを見てもらいたい」のか？**

後者であれば、必ずしもOGP画像自体にスコアが焼き付いている必要はありません。

### 採用したアーキテクチャ
最終的に、**「動的画像生成は廃止する」** という決断をしました。

*   **シェアボタン**: シンプルなテキストベース。「スコア: 10,000pt でランク Legend を獲得しました！URL...」というテキストをXに投げるだけ。
*   **OGP画像**: サイト共通のきれいな静的画像を使用。
*   **重要**: **「シェアされたURLの飛び先（結果ページ）」** で、リッチなReactコンポーネント (`<ScoreCard />`) を表示する。

```tsx
// src/app/share/result/page.tsx
export default function SharePage({ searchParams }) {
  // OGP画像生成APIを叩くのではなく、
  // Reactコンポーネントとして普通にレンダリングする
  return (
    <div className="center-layout">
      <ScoreCard 
        score={searchParams.score} 
        rank={searchParams.rank} 
      />
      <Button>今すぐプレイ</Button>
    </div>
  );
}
```

### メリット
1.  **爆速**: 画像生成処理がないため、シェアボタンを押した瞬間にTwitterが立ち上がる。
2.  **安定性**: サーバーレス関数のタイムアウトやアセット読み込みエラーに怯える必要がない。
3.  **開発効率**: Reactコンポーネント (`ScoreCard`) を作るだけで、ビューとシェア結果画面の両方を兼ねられる（コードの再利用）。

## まとめ

技術的には「動的OGP生成」は魅力的で、成功すればカッコいい機能です。しかし、**「リソースが限られた個人開発」** においては、メンテナンスコストや実装の複雑さが足枷になることもあります。

**「動的な機能（Server Side）」を「静的なコンポーネント（Client/React Side）」に置き換える** ことで、機能のコア（スコアを見せる）を維持したまま、システムの堅牢性を劇的に高めることができました。

「実装できない」と諦めたのではなく、**「実装しないほうがユーザーにとっても開発者にとっても幸せである」** という判断ができた、という意味で良い経験でした。
